# 緒
很久以前有個朋友有一天突然LINE我說："ㄟㄟ，我終於知道資工跟資管的差距在哪了。"接者丟了一題 Leetcode 給我。題目很簡單，就一句話：

```Java
Given a non-empty array of integers, every element appears twice except for one. Find that single one.
```
跟我說第一名的答案用 XOR 來解，程式碼如下：
![]()

說實在當下是驚艷的，因為這種透過位元運算的解法在當時對我來說是聞所未聞的。不禁捏了把冷汗，又想到曾經看過一句話：我的三維世界是二進制的...

`但同時我想反駁的是，這不是資工跟資管的差距，只是人跟人之間的差距罷了。
`

最近對岸很紅的工程師 - 郭宇，28歲達到財務自由，退休旅居日本經營溫泉旅館。人家大學讀的是政治與行政管理...

很多人將自己不會的東西要歸咎在自己念的科系上；亦或是將實力與科系綑綁這種刻板印象。

誠心希望台灣技術圈能少一點刻板的比較，多一點理性的討論，回歸科學的初衷，互相學習成長。

有點扯遠了 XD 繼續回來位元運算的話題 ~

剛好最近看了一下 HashMap 的原始碼，截一段分享一下：

```Java
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```

這是甚麼小朋友？

看到 HashMap Source Code 裡充滿了這種異國風情的 Code，又猛然想起多年前那位朋友的那一番話，於是痛定思痛，決定好好來填充一下這人跟人之間的差距。

# 聊聊位元運算
在計算機系統中數據是由二進制表示，二進制中的一位元，是資訊的最小單位。而位元運算，指的是直接對記憶體中的二進制位元進行操作，因此執行效率非常高。適當使用會大大提高程式的性能。

先來看看基本的位元運算操作：
## 位元OR
位元或運算

Example:
```Java
int a = 45;
int b = 25;
System.out.println(a | b);
```

Result:
```Java
//  a = 00000000000000000000000000101101
//  b = 00000000000000000000000000011001
61  //  00000000000000000000000000111101
```

## 位元AND
位元且運算

Example:
```Java
int a = 45;
int b = 25;
System.out.println(a & b);
```

Result:
```Java
//   a = 00000000000000000000000000101101
//   b = 00000000000000000000000000011001
9    //  00000000000000000000000000001001
```

## 位元XOR
位元互斥或運算

Example:
```Java
int a = 45;
int b = 25;
System.out.println(a & b);
```

Result:
```Java
// a = 00000000000000000000000000101101
// b = 00000000000000000000000000011001
52  // 00000000000000000000000000110100
```

## 位元補數
位元取反，0變1、1變0

Example:
```Java
int a = 45;
System.out.println(a);
a = ~a;
System.out.println(a);
```

Result:
```Java
45    // 00000000000000000000000000101101
-46   // 11111111111111111111111111010010
```
## 位移運算
進行位元的位移操作，又區分有號位移與無號位移
### 有號位移
- " << " 左移運算：向左進行位移運算，高位丟棄，低位補0
```Java
int a = 8;
a << 3;

移位前：0000 0000 0000 0000 0000 0000 0000 1000
移位後：0000 0000 0000 0000 0000 0000 0100 0000
```

- " >> " 右移運算：向右進行位移運算，無號數高位補0；有號數高位補符號位
```Java
unsigned int a = 8;
a >> 3;

移位前：0000 0000 0000 0000 0000 0000 0000 1000
移位後：0000 0000 0000 0000 0000 0000 0000 0001
​
int a = -8;
a >> 3;

移位前：1111 1111 1111 1111 1111 1111 1111 1000
移位後：1111 1111 1111 1111 1111 1111 1111 1111
```
### 無號位移
基本同上，差別在右移時不管符號高位直接補0
- 無號右移運算
```Java
//
```

# 奇技淫巧
以上稍微聊過位元運算的基本操作，接下來來看看有哪些其有哪些經(奇)典(技)應(淫)用(巧)吧

## 判斷數字的奇偶性
透過判斷數字二進制位元最低位是否為0來得知其奇偶性
```Java
public void Test(int a){
    if((a & 1) == 0){
        System.out.println("a是偶數");
    }else{
        System.out.println("a是奇數");
    }
}
```

## 不使用temp交換兩變數值
利用 XOR 自反性： A XOR B XOR B = A XOR 0 = A
```Java
public void exchange(int a,int y){
    x ^= y;
    y ^= x;
    x ^= y;
}
```

## 不用加減乘除做加法
```Java
public int Add(int a,int b){
    return b == 0 ? a : Add(a ^ b, (a & b) << 1);
}
```
- 用 XOR 模擬不進位加法 (a ^ b)，得出不進位相加結果
- (a & b) << 1 計算進位值
  - (a & b) 為判斷每位元是否進位
  - << 1 取得最終進位結果
- 每回 recursion 將 (a ^ b) 與 (a & b) << 1 作相加，直到進位值為0


# 小結
這篇文章主要分享了一些位元運算的基本操作與花式操作，希望能對它有個基本的了解，不至於看不懂一些原始碼。

適當的使用位元運算可以提升程式的效率，但不應一味的追求簡化而忽視了效率，反而本末倒置。如果覺得對你有幫助，可以幫我點個讚，也歡迎留言交流~~~~
# 參考
- [位元運算子 Bitwise Operator](https://yubin551.gitbooks.io/java-note/bitwise_operators.html)
- [C和C++运算符](https://zh.wikipedia.org/zh-hans/C%E5%92%8CC%2B%2B%E9%81%8B%E7%AE%97%E5%AD%90)
